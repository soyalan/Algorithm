# README

[TOC]

## 1st



> 09.04 ~ 09.11



---

### 1.1 탐색과 정렬 (1)



#### 1920 수 찾기

> 탐색 개수가 10만 x 10만이므로 완전 탐색 불가능
>
> 이진 탐색 (Binary Search) 사용
>
> <algorithm> 안에 있는 binary_serach 사용
>
> ```cpp
> bool x = binary_search(v.begin(), v.end(), number);
> ```



#### 2750 수 정렬하기

> 단순 정렬
>
> sort 사용



#### 2751 수 정렬하기 2

> 위의 문제와 동일



#### 10989 수 정렬하기 

> N이 굉장히 크고 입력 값이 10000 이내의 자연수이므로
>
> counting sort 사용



#### 10815 숫자 카드

> 1920번 수 찾기 문제와 동일



---

### 1.2 기초 자료구조 (1)



#### 10828 스택

> vector 사용
>
> 단순히 *char을 사용해 문자열 입력 후 
>
> strcmp로 문자열 비교



#### 10845 큐

> queue 사용
>
> 나머진 스택과 동일



#### 10866 덱

> deque 사용
>
> 나머진 동일



#### 1406 에디터

> vector를 사용하려 하였으나
>
> insert, erase가 시간 초과를 유발
>
> list로 변경



---

### 1.3 탐색과 정렬 (2)



#### 1026 보물

> 단순 정렬
>
> A는 오름차순
>
> B는 내림차순



#### 1181 단어 정렬

> vector 이용
>
> unique를 이용해서 중복 제거
>
> compare 함수를 만들어 정렬



#### 11650 좌표 정렬하기

> 단순 정렬



#### 11651 좌표 정렬하기 2

> 위의 문제와 동일



#### 10867 중복 빼고 정렬하기

> unique 함수는 중복을 제거하는 함수가 아니라 중복을 마지막으로 밀어냄
>
> 따라서 배열을 끝까지 돌리면 중복이 나옴
>
> ```cpp
> it2 = unique(v.begin(), v.end());
> ```
>
> iterator가 중복이 아닌 마지막 값에 위치
>
> 즉, 아래처럼 for문을 돌리면 중복이 나오지 않음
>
> ```cpp
> for (it = v.begin(); it != it2; it++) {
> ```



#### 10816 숫자 카드 2

> upper_bound, lower_bound 사용 -> 정렬이 되어있어야 함
>
> ```cpp
> upper_bound(v.begin(), v.end(), num);
> lower_bound(v.begin(), v.end(), num);
> ```
>
> lower_bound는 그 값에서 가장 가까운 아래를 리턴
>
> 동일하게 upper_bound는 그 값에서 가장 가까운 위를 리턴함
>
> 따라서 upper에서 lower를 뺀다면 해당 값이 있는 경우는 중간 값이 발생
>
> 